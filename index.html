<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Scoreboard</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #f832e7, #d1206e, #f8770f);
    background-size: 600% 600%;
    animation: gradientBG 20s ease infinite;
    color: #fff;
    text-align: center;
    padding: 20px;
    margin: 0;
  }
  @keyframes gradientBG {
    0% {background-position: 0% 50%;}
    50% {background-position: 100% 50%;}
    100% {background-position: 0% 50%;}
  }

  h1, h2 { margin-bottom: 20px; }

  #controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-width: 800px;
    margin: 0 auto 30px auto;
    padding: 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
  }
  .control-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
  }
  .control-group input,
  .control-group select,
  .control-group button {
    flex: 1 1 auto;
    min-width: 120px;
    max-width: 180px;
    padding: 8px;
    font-size: 14px;
    border: none;
    border-radius: 5px;
  }
  button {
    background-color: #6a11cb;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  button:hover { background-color: #2575fc; }

  /* SCOREBOARD STYLING */
  #scoreboard {
    max-width: 800px;
    margin: 40px auto;
    text-align: left;
    display: flex;
    flex-direction: column;
    gap: 10px;
    position: relative;
  }
  .entry {
    background: #2a2a2a;
    padding: 20px;
    margin: 5px 0;
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    transition: transform 0.6s ease, background-color 0.4s ease, opacity 0.5s ease;
  }
  .entry.highlight {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.03);
  }
  .entry.new-entry {
    opacity: 0;
    transform: translateY(-20px);
  }
  .entry.show {
    opacity: 1;
    transform: translateY(0);
  }
  .score {
    font-size: 24px;
    font-weight: bold;
    min-width: 100px;
    text-align: right;
  }

  /* Green screen mode */
  .green-screen {
    background: #00ff00 !important;
  }
</style>
</head>
<body>
<h1>ðŸŽ¤ Scoreboard Voting</h1>

<div id="controls">
  <div class="control-group">
    <input id="personName" type="text" placeholder="Enter name" />
    <button onclick="addPerson()">Add Person</button>
  </div>
  <div class="control-group">
    <select id="sharedNameSelect"></select>
    <input id="pointsInput" type="number" placeholder="Points" />
    <select id="pointType">
      <option value="jury">Jury</option>
      <option value="public">Audience</option>
    </select>
    <button onclick="addPoints()">Add Points</button>
  </div>
  <div class="control-group">
    <button onclick="undoLastAction()">Undo Last Action</button>
    <button onclick="toggleGreenScreen()">ðŸ’š Toggle Green Screen</button>
  </div>
</div>

<h2>ðŸ“Š Leaderboard</h2>
<div id="scoreboard"></div>

<script>
  const people = {};
  const history = [];

  function saveState() {
    history.push(JSON.parse(JSON.stringify(people)));
    if (history.length > 50) history.shift();
  }

  function undoLastAction() {
    if (history.length === 0) return;
    const prevState = history.pop();
    for (const key in prevState) {
      people[key] = prevState[key];
    }
    updateScoreboard();
  }

  function addPerson() {
    const name = document.getElementById('personName').value.trim();
    if (name && !people[name]) {
      saveState();
      people[name] = { jury: 0, public: 0, total: 0 };
      updateSelect();
      updateScoreboard();
    }
    document.getElementById('personName').value = '';
  }

  function updateSelect() {
    const select = document.getElementById('sharedNameSelect');
    select.innerHTML = '';
    for (const name in people) {
      const option = document.createElement('option');
      option.value = name;
      option.textContent = name;
      select.appendChild(option);
    }
  }

  function animateCountUp(element, from, to, duration = 1000) {
    const start = performance.now();
    function step(timestamp) {
      const progress = Math.min((timestamp - start) / duration, 1);
      const value = Math.floor(from + (to - from) * progress);
      element.textContent = value + ' pts';
      if (progress < 1) {
        requestAnimationFrame(step);
      }
    }
    requestAnimationFrame(step);
  }

  function addPoints() {
    const name = document.getElementById('sharedNameSelect').value;
    const points = parseInt(document.getElementById('pointsInput').value);
    const type = document.getElementById('pointType').value;
    if (name && !isNaN(points) && people[name]) {
      saveState();
      people[name][type] += points;
      updateScoreboard(name);
      document.getElementById('pointsInput').value = '';
    }
  }

  function toggleGreenScreen() {
    document.body.classList.toggle('green-screen');
  }

  function updateScoreboard(highlightName = null) {
    const board = document.getElementById('scoreboard');
    const sorted = Object.entries(people).sort((a, b) => {
      const totalA = a[1].jury + a[1].public;
      const totalB = b[1].jury + b[1].public;
      return totalB - totalA;
    });

    // Store old positions for FLIP animation
    const oldPositions = new Map();
    Array.from(board.children).forEach(child => {
      oldPositions.set(child.dataset.name, child.getBoundingClientRect().top);
    });

    // Rebuild scoreboard
    board.innerHTML = '';
    sorted.forEach(([name, scores], index) => {
      const total = scores.jury + scores.public;
      scores.total = total;

      const entry = document.createElement('div');
      entry.className = 'entry';
      entry.dataset.name = name;

      entry.innerHTML = `
        <div class="label"><strong>#${index + 1} ${name}</strong><br>
        <small>Jury: ${scores.jury}, Audience: ${scores.public}</small></div>
        <div class="score" data-total="${total}">${total} pts</div>
      `;

      if (name === highlightName) {
        entry.classList.add('highlight');
        setTimeout(() => entry.classList.remove('highlight'), 1000);
      }

      board.appendChild(entry);
    });

    // FLIP animation
    const newPositions = new Map();
    Array.from(board.children).forEach(child => {
      newPositions.set(child.dataset.name, child.getBoundingClientRect().top);
    });

    newPositions.forEach((newTop, name) => {
      const oldTop = oldPositions.get(name);
      if (oldTop !== undefined) {
        const delta = oldTop - newTop;
        const element = board.querySelector(`[data-name="${name}"]`);
        element.style.transform = `translateY(${delta}px)`;
        element.style.transition = 'none';
        requestAnimationFrame(() => {
          element.style.transition = 'transform 0.6s ease';
          element.style.transform = '';
        });
      }
    });
  }
</script>
</body>
</html>

